#! /usr/bin/java  --class-path ./kafka_2.13-3.6.1/libs/* --source 17

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Properties;
import java.util.concurrent.ExecutionException;

import org.apache.kafka.clients.producer.KafkaProducer;
import org.apache.kafka.clients.producer.ProducerRecord;

import java.util.Random;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

class App {

    final static String cities[] = {
        "Atlanta", "Austin", "Baltimore", "Boston", "Charlotte", "Chicago", "Cincinnati", "Cleveland",
                "Columbus", "Dallas", "Denver", "Detroit", "Fort Worth", "Houston", "Indianapolis", "Jacksonville",
                "Kansas City", "Las Vegas", "Los Angeles", "Louisville", "Memphis", "Miami", "Milwaukee",
                "Minneapolis", "Nashville", "New Orleans", "New York", "Oklahoma City", "Orlando", "Philadelphia",
                "Phoenix", "Pittsburgh", "Portland", "Raleigh", "Richmond", "Sacramento", "Salt Lake City",
                "San Antonio", "San Diego", "San Francisco", "San Jose", "Seattle", "St. Louis",
                "Tampa", "Tucson", "Washington"
    };

    public static int seed = 32;
    public static int nThreads = 10;
    public static int records = 1000000000;


    public static void main(String[] args) throws Exception {
        // Measure time to produce 1 billion records
        long start = System.currentTimeMillis();
        System.out.println("Generating data...");

        ExecutorService executorService = Executors.newFixedThreadPool(nThreads);
        for (int i = 0; i < nThreads; i++) {
            executorService.execute(() -> {generateData();}
            );
        }

        // wait for all threads to finish
        executorService.shutdown();

        long end = System.currentTimeMillis();
        String output = String.format("Time to produce 1 billion records: %f seconds", (end - start) / 1000.0);
        System.out.println(output);
    }

    public static void generateData() {
        Thread t = Thread.currentThread();
        long threadId = (t.getId() % 10)+1;
        System.out.println("Thread ID: " + threadId);
        // for 0 to records/nThreads
        for (int i = 0; i < records / nThreads; i++) {
            // create a new instance of the KafkaProducer
            Properties props = new Properties();
            props.put("bootstrap.servers", "localhost:9092");
            props.put("acks", "1");
            props.put("batch.size", Integer.toString(16384*10));
            props.put("linger.ms", 100);
            props.put("compression.type", "lz4");
            props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");
            props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");
            KafkaProducer<String, String> producer = new KafkaProducer<>(props);

            // create a random record
            Random rand = new Random(seed*threadId);
            int cityIndex = rand.nextInt(cities.length);
            String city = cities[cityIndex];
            String temperature = String.valueOf(rand.nextInt(55));

            // send the record to the topic
            producer.send(new ProducerRecord<>("test", city, temperature));

            // flush and close producer
            producer.flush();
            producer.close();
        }
    }
}